<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exam in Progress</title>
    <link rel="icon" type="image/png" href="logo-light.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }
        
        /* Prevent text selection and right-click */
        body {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Allow text selection in input fields */
        textarea, input {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .exam-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timer {
            font-size: 24px;
            font-weight: bold;
        }
        
        .warning-banner {
            background: #ff9800;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            display: none;
        }
        
        .warning-banner.show {
            display: block;
        }
        
        .exam-container {
            display: flex;
            height: calc(100vh - 120px);
        }
        
        .video-panel {
            width: 250px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        #webcam {
            width: 100%;
            border-radius: 10px;
            background: #000;
        }
        
        .status-indicator {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
        }
        
        .status-good {
            background: #d4edda;
            color: #155724;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-danger {
            background: #f8d7da;
            color: #721c24;
        }
        
        .question-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }
        
        .question-card {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        
        .question-number {
            font-size: 18px;
            font-weight: 600;
            color: #667eea;
        }
        
        .question-points {
            color: #666;
        }
        
        .question-text {
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            margin-bottom: 20px;
        }
        
        .options {
            margin: 20px 0;
        }
        
        .option {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .option.selected {
            border-color: #667eea;
            background: #e8ebff;
        }
        
        .option input[type="radio"] {
            margin-right: 10px;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            background: white;
            color: #333;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .word-count {
            text-align: right;
            color: #666;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-submit {
            background: #28a745;
            color: white;
        }
        
        .btn-submit:hover {
            background: #218838;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
        }
        
        .modal-content h2 {
            color: #e74c3c;
            margin-bottom: 20px;
        }
        
        .fullscreen-request {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .fullscreen-request h1 {
            margin-bottom: 20px;
        }
        
        .fullscreen-request p {
            max-width: 600px;
            line-height: 1.6;
        }
        
        .fullscreen-request button {
            padding: 15px 40px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .fullscreen-request button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <!-- Fullscreen Request Overlay -->
    <div id="fullscreenRequest" class="fullscreen-request">
        <h1>‚ö†Ô∏è Exam Proctoring Active</h1>
        <p style="margin-bottom: 20px; font-size: 18px;">This exam requires fullscreen mode<span id="webcamRequired"> and webcam access</span>.</p>
        <p style="margin-bottom: 30px; font-size: 14px; color: #ccc;">
            When you click "Start Exam", your browser <span id="webcamNote">will ask for webcam permission.<br>Please click "Allow" to proceed.</span>
            <span id="httpsWarning" style="display: none; color: #ff9800;"><br><br>‚ö†Ô∏è Note: Webcam access requires HTTPS. If you encounter issues, access this exam from the server at http://localhost:5000</span>
        </p>
        <button onclick="requestFullscreenAndWebcam()" id="startExamBtn">Start Exam</button>
    </div>
    
    <script>
        // Check and display warnings early
        const examSessionCheck = JSON.parse(localStorage.getItem('examSession'));
        if (examSessionCheck && !examSessionCheck.proctoring_settings.video_monitoring) {
            document.getElementById('webcamRequired').style.display = 'none';
            document.getElementById('webcamNote').textContent = 'will request fullscreen mode.';
        } else if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
            document.getElementById('httpsWarning').style.display = 'inline';
        }
    </script>
    
    <!-- Warning Banner -->
    <div id="warningBanner" class="warning-banner"></div>
    
    <!-- Exam Header -->
    <div class="exam-header" style="display: none;" id="examHeader">
        <h2 id="examTitle"></h2>
        <div class="timer" id="timer">00:00:00</div>
    </div>
    
    <!-- Main Exam Container -->
    <div class="exam-container" style="display: none;" id="examContainer">
        <!-- Video Panel -->
        <div class="video-panel">
            <video id="webcam" autoplay muted></video>
            <div id="statusIndicator" class="status-indicator status-good">
                ‚úì Monitoring Active
            </div>
            <div style="margin-top: 15px; font-size: 12px; color: #666;">
                <div>Tab Switches: <span id="tabSwitches">0</span></div>
                <div>Violations: <span id="violations">0</span></div>
            </div>
        </div>
        
        <!-- Questions Panel -->
        <div class="question-panel">
            <div id="questionsContainer"></div>
            
            <div class="navigation">
                <button class="btn btn-secondary" onclick="previousQuestion()" id="prevBtn">‚Üê Previous</button>
                <button class="btn btn-primary" onclick="nextQuestion()" id="nextBtn">Next ‚Üí</button>
                <button class="btn btn-submit" onclick="submitExam()" id="submitBtn" style="display: none;">Submit Exam</button>
            </div>
        </div>
    </div>
    
    <!-- Violation Modal -->
    <div id="violationModal" class="modal">
        <div class="modal-content">
            <h2>‚ö†Ô∏è Violation Detected</h2>
            <p id="violationMessage"></p>
            <button class="btn btn-primary" onclick="closeViolationModal()">I Understand</button>
        </div>
    </div>

    <script>
        const API_URL = 'https://plagiarismchecker-production.up.railway.app/api';
        let token = localStorage.getItem('token');
        let examSession = JSON.parse(localStorage.getItem('examSession'));
        
        if (!token || !examSession) {
            window.location.href = 'candidate.html';
        }
        
        let currentQuestionIndex = 0;
        let questions = examSession.questions;
        let answers = {};
        let timerInterval;
        let videoStream;
        let tabSwitchCount = 0;
        let violationCount = 0;
        let isFullscreen = false;
        let faceDetectionInterval;
        let mediaRecorder;
        let recordedChunks = [];
        let recordingStartTime;
        
        // Disable copy, paste, cut
        document.addEventListener('copy', preventAction);
        document.addEventListener('paste', preventAction);
        document.addEventListener('cut', preventAction);
        
        // Disable right-click
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Disable keyboard shortcuts and detect workspace switching
        document.addEventListener('keydown', function(e) {
            // Prevent ESC key to exit fullscreen
            if ((e.key === 'Escape' || e.keyCode === 27) && isFullscreen) {
                e.preventDefault();
                e.stopPropagation();
                showWarning('‚ö†Ô∏è You cannot exit fullscreen during the exam!');
                return false;
            }
            
            // Prevent F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
            if (e.keyCode == 123 || // F12
                (e.ctrlKey && e.shiftKey && (e.keyCode == 73 || e.keyCode == 74)) ||
                (e.ctrlKey && e.keyCode == 85)) {
                e.preventDefault();
                reportViolation('shortcut', 'Attempted to use developer tools');
                return false;
            }
            
            // Detect workspace switching
            // Windows: Ctrl+Win+Arrow, Linux: Ctrl+Alt+Arrow, Super+PageUp/PageDown
            const isWorkspaceSwitch = 
                (e.ctrlKey && (e.metaKey || e.altKey) && (e.keyCode === 37 || e.keyCode === 39)) || // Ctrl+Win/Alt+Left/Right
                (e.metaKey && (e.keyCode === 33 || e.keyCode === 34)) || // Super+PageUp/PageDown
                (e.ctrlKey && e.altKey && (e.keyCode === 38 || e.keyCode === 40)); // Ctrl+Alt+Up/Down
            
            if (isWorkspaceSwitch) {
                e.preventDefault();
                tabSwitchCount++;
                document.getElementById('tabSwitches').textContent = tabSwitchCount;
                reportViolation('workspace_switch', 'Attempted to switch workspace/virtual desktop');
                showWarning('‚ö†Ô∏è Warning: Workspace switching is not allowed during the exam!');
                updateSessionProctoring();
                return false;
            }
        }, true);
        
        // Detect tab/window changes
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                tabSwitchCount++;
                document.getElementById('tabSwitches').textContent = tabSwitchCount;
                reportViolation('tab_switch', 'Tab or window switched during exam');
                showWarning('‚ö†Ô∏è Warning: Tab switching detected! Stay on the exam page.');
                updateSessionProctoring();
            }
        });
        
        // Detect window blur (catches workspace switching that keyboard events miss)
        let lastBlurTime = 0;
        window.addEventListener('blur', function() {
            const now = Date.now();
            // Only count if exam is active and not duplicate event (debounce 1 second)
            if (examSession && (now - lastBlurTime > 1000)) {
                lastBlurTime = now;
                tabSwitchCount++;
                document.getElementById('tabSwitches').textContent = tabSwitchCount;
                reportViolation('window_blur', 'Window lost focus - possible workspace/window switch');
                showWarning('‚ö†Ô∏è Warning: Switching away from the exam is not allowed!');
                updateSessionProctoring();
            }
        });
        
        // Detect and prevent fullscreen exit
        document.addEventListener('fullscreenchange', function() {
            const wasFullscreen = isFullscreen;
            isFullscreen = !!document.fullscreenElement;
            
            // If user exits fullscreen during exam, force them back in
            if (wasFullscreen && !isFullscreen && examSession) {
                reportViolation('fullscreen_exit', 'Attempted to exit fullscreen mode');
                showWarning('‚ö†Ô∏è Warning: You cannot exit fullscreen during the exam!');
                
                // Force back to fullscreen after short delay
                setTimeout(() => {
                    if (!isFullscreen) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.error('Failed to re-enter fullscreen:', err);
                        });
                    }
                }, 500);
            }
        });
        

        
        function preventAction(e) {
            e.preventDefault();
            reportViolation(e.type, `Attempted to ${e.type} content`);
            showViolationModal(`${e.type.charAt(0).toUpperCase() + e.type.slice(1)} is disabled during the exam.`);
            
            // Track specific violation type
            if (e.type === 'copy') {
                updateSessionProctoring();
            } else if (e.type === 'paste') {
                updateSessionProctoring();
            }
        }
        
        async function requestFullscreenAndWebcam() {
            const btn = document.getElementById('startExamBtn');
            btn.disabled = true;
            btn.textContent = 'Requesting Permissions...';
            
            try {
                // Check if video monitoring is required
                const needsWebcam = examSession.proctoring_settings.video_monitoring;
                
                if (needsWebcam) {
                    // Check if getUserMedia is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('WEBCAM_NOT_SUPPORTED: Your browser does not support webcam access, or the page must be accessed over HTTPS.');
                    }
                    
                    // Request webcam
                    console.log('Requesting webcam access...');
                    videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 640, height: 480 },
                        audio: false 
                    });
                    
                    console.log('Webcam access granted');
                    document.getElementById('webcam').srcObject = videoStream;
                    
                    // Start recording video for admin review
                    startVideoRecording();
                }
                
                // Request fullscreen
                console.log('Requesting fullscreen...');
                await document.documentElement.requestFullscreen();
                isFullscreen = true;
                console.log('Fullscreen granted');
                
                // Hide request overlay and show exam
                document.getElementById('fullscreenRequest').style.display = 'none';
                document.getElementById('examHeader').style.display = 'flex';
                document.getElementById('examContainer').style.display = 'flex';
                
                // Hide video panel if webcam not needed
                if (!needsWebcam) {
                    document.querySelector('.video-panel').style.display = 'none';
                }
                
                // Initialize exam
                initializeExam();
                
                // Start face detection
                if (needsWebcam) {
                    startFaceDetection();
                }
                
            } catch (error) {
                console.error('Permission error:', error);
                btn.disabled = false;
                btn.textContent = 'Start Exam';
                
                if (error.message && error.message.includes('WEBCAM_NOT_SUPPORTED')) {
                    alert('‚ùå Webcam Access Not Available\n\n' +
                          'This exam requires webcam access, but:\n\n' +
                          '‚Ä¢ Your browser may not support webcam access\n' +
                          '‚Ä¢ The page must be accessed over HTTPS (secure connection)\n' +
                          '‚Ä¢ You are accessing via HTTP on IP: ' + window.location.host + '\n\n' +
                          'Solutions:\n' +
                          '1. Access the exam from the server itself at http://localhost:5000\n' +
                          '2. Set up HTTPS/SSL certificate for this server\n' +
                          '3. Ask admin to disable video monitoring for this exam');
                    setTimeout(() => window.location.href = 'candidate.html', 3000);
                } else if (error.name === 'NotAllowedError') {
                    alert('‚ùå Permission Denied\n\nWebcam and fullscreen access are required to take this exam.\n\nPlease:\n1. Click the camera icon in your address bar\n2. Allow camera access\n3. Try again');
                } else if (error.name === 'NotFoundError') {
                    alert('‚ùå No Webcam Found\n\nNo webcam was detected on your device. A webcam is required for this proctored exam.');
                    setTimeout(() => window.location.href = 'candidate.html', 2000);
                } else {
                    alert('‚ùå Error: ' + error.message + '\n\nWebcam and fullscreen access are required. Please grant permissions and try again.');
                }
            }
        }
        
        function initializeExam() {
            document.getElementById('examTitle').textContent = examSession.exam_title;
            
            // Start timer
            startTimer();
            
            // Load first question
            displayQuestion(0);
        }
        
        function startTimer() {
            const startTime = new Date(examSession.started_at).getTime();
            const durationMs = examSession.duration_minutes * 60 * 1000;
            const endTime = startTime + durationMs;
            
            timerInterval = setInterval(() => {
                const now = new Date().getTime();
                const timeLeft = endTime - now;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    autoSubmitExam();
                    return;
                }
                
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                
                document.getElementById('timer').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Warning when 5 minutes left
                if (timeLeft <= 5 * 60 * 1000 && timeLeft > 4 * 60 * 1000) {
                    showWarning('‚è∞ Only 5 minutes remaining!');
                }
            }, 1000);
        }
        
        function displayQuestion(index) {
            currentQuestionIndex = index;
            const question = questions[index];
            const container = document.getElementById('questionsContainer');
            
            let html = `
                <div class="question-card">
                    <div class="question-header">
                        <div class="question-number">Question ${index + 1} of ${questions.length}</div>
                        <div class="question-points">${question.points} point${question.points > 1 ? 's' : ''}</div>
                    </div>
                    <div class="question-text">${question.question_text}</div>
            `;
            
            if (question.question_type === 'mcq') {
                html += '<div class="options">';
                question.options.forEach((option, idx) => {
                    const letter = String.fromCharCode(65 + idx);
                    const isSelected = answers[question.id] === letter;
                    html += `
                        <div class="option ${isSelected ? 'selected' : ''}" onclick="selectOption(${question.id}, '${letter}')">
                            <input type="radio" name="q${question.id}" value="${letter}" ${isSelected ? 'checked' : ''}>
                            <strong>${letter}.</strong> ${option}
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                const savedAnswer = answers[question.id] || '';
                html += `
                    <textarea id="answer_${question.id}" onkeyup="updateAnswer(${question.id})" placeholder="Type your answer here...">${savedAnswer}</textarea>
                    <div class="word-count" id="wordcount_${question.id}">
                        ${countWords(savedAnswer)} words${question.max_words ? ' / ' + question.max_words + ' max' : ''}
                    </div>
                `;
            }
            
            html += '</div>';
            container.innerHTML = html;
            
            // Update navigation buttons
            document.getElementById('prevBtn').style.display = index === 0 ? 'none' : 'inline-block';
            document.getElementById('nextBtn').style.display = index === questions.length - 1 ? 'none' : 'inline-block';
            document.getElementById('submitBtn').style.display = index === questions.length - 1 ? 'inline-block' : 'none';
        }
        
        function selectOption(questionId, option) {
            answers[questionId] = option;
            saveAnswer(questionId, null, option);
            
            // Update UI
            const options = document.querySelectorAll('.option');
            options.forEach(opt => opt.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function updateAnswer(questionId) {
            const textarea = document.getElementById(`answer_${questionId}`);
            const answer = textarea.value;
            answers[questionId] = answer;
            
            // Update word count
            const wordCount = countWords(answer);
            const question = questions.find(q => q.id === questionId);
            document.getElementById(`wordcount_${questionId}`).textContent = 
                `${wordCount} words${question.max_words ? ' / ' + question.max_words + ' max' : ''}`;
            
            // Auto-save after 2 seconds of no typing
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                saveAnswer(questionId, answer, null);
            }, 2000);
        }
        
        function countWords(text) {
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }
        
        async function saveAnswer(questionId, answerText, selectedOption) {
            try {
                await fetch(`${API_URL}/exam/session/${examSession.session_id}/answer`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_id: questionId,
                        answer_text: answerText,
                        selected_option: selectedOption
                    })
                });
            } catch (error) {
                console.error('Error saving answer:', error);
            }
        }
        
        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                displayQuestion(currentQuestionIndex - 1);
            }
        }
        
        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                displayQuestion(currentQuestionIndex + 1);
            }
        }
        
        async function submitExam() {
            if (!confirm('Are you sure you want to submit your exam? You cannot change your answers after submission.')) {
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/exam/session/${examSession.session_id}/submit`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Stop recording and upload video
                    await stopVideoRecording();
                    
                    // Stop video and timer
                    if (videoStream) {
                        videoStream.getTracks().forEach(track => track.stop());
                    }
                    clearInterval(timerInterval);
                    clearInterval(faceDetectionInterval);
                    
                    // Exit fullscreen
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                    
                    // Clear session
                    localStorage.removeItem('examSession');
                    
                    // Show result without score
                    alert('Exam submitted successfully!\n\nYour exam has been submitted for evaluation.\nResults will be available once grading is complete.');
                    window.location.href = 'candidate.html';
                } else {
                    alert('Error submitting exam. Please try again.');
                }
            } catch (error) {
                console.error('Error submitting exam:', error);
                alert('Connection error. Please check your internet and try again.');
            }
        }
        
        function autoSubmitExam() {
            alert('Time is up! Your exam will be submitted automatically.');
            submitExam();
        }
        
        async function reportViolation(type, description) {
            violationCount++;
            document.getElementById('violations').textContent = violationCount;
            
            try {
                await fetch(`${API_URL}/proctoring/violation`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: examSession.session_id,
                        violation_type: type,
                        description: description,
                        severity: type === 'fullscreen_exit' ? 'high' : 'medium'
                    })
                });
            } catch (error) {
                console.error('Error reporting violation:', error);
            }
        }
        
        async function updateSessionProctoring() {
            try {
                await fetch(`${API_URL}/proctoring/update-stats`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: examSession.session_id,
                        tab_switches: tabSwitchCount
                    })
                });
            } catch (error) {
                console.error('Error updating proctoring stats:', error);
            }
        }
        
        function showWarning(message) {
            const banner = document.getElementById('warningBanner');
            banner.textContent = message;
            banner.classList.add('show');
            
            setTimeout(() => {
                banner.classList.remove('show');
            }, 5000);
        }
        
        function showViolationModal(message) {
            document.getElementById('violationMessage').textContent = message;
            document.getElementById('violationModal').classList.add('active');
        }
        
        function closeViolationModal() {
            document.getElementById('violationModal').classList.remove('active');
        }
        
        function startFaceDetection() {
            // Simple face detection based on video stream
            // In production, you would use a proper face detection library
            faceDetectionInterval = setInterval(() => {
                const video = document.getElementById('webcam');
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    // Placeholder for face detection logic
                    // You could integrate TensorFlow.js or Face-API.js here
                    document.getElementById('statusIndicator').className = 'status-indicator status-good';
                    document.getElementById('statusIndicator').textContent = '‚úì Monitoring Active';
                }
            }, 3000);
        }
        
        async function startVideoRecording() {
            try {
                // Request screen capture instead of just webcam
                let screenStream;
                
                if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                    try {
                        // Try to capture entire screen automatically
                        screenStream = await navigator.mediaDevices.getDisplayMedia({
                            video: { 
                                cursor: "always",
                                displaySurface: "monitor"
                            },
                            audio: false,
                            preferCurrentTab: false,
                            selfBrowserSurface: "exclude",
                            systemAudio: "exclude"
                        });
                        
                        console.log('Screen capture started');
                        
                    } catch (screenError) {
                        console.log('Screen capture not available or denied, using webcam only');
                        screenStream = videoStream;
                    }
                } else {
                    // Fallback to webcam only
                    screenStream = videoStream;
                }
                
                if (!screenStream) return;
                
                recordedChunks = [];
                recordingStartTime = Date.now();
                
                // Create media recorder with screen stream
                const options = { mimeType: 'video/webm;codecs=vp8' };
                mediaRecorder = new MediaRecorder(screenStream, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                // Record in chunks of 10 seconds
                mediaRecorder.start(10000);
                console.log('Video recording started');
                
                document.getElementById('statusIndicator').innerHTML = 'üî¥ Recording';
            } catch (error) {
                console.error('Error starting video recording:', error);
            }
        }
        
        async function stopVideoRecording() {
            return new Promise((resolve) => {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    resolve();
                    return;
                }
                
                mediaRecorder.onstop = async () => {
                    console.log('Video recording stopped');
                    
                    // Create blob from recorded chunks
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const recordingDuration = (Date.now() - recordingStartTime) / 1000;
                    
                    console.log(`Recording duration: ${recordingDuration}s, Size: ${(blob.size / 1024 / 1024).toFixed(2)}MB`);
                    
                    // Upload video to server
                    try {
                        const formData = new FormData();
                        formData.append('video', blob, `session_${examSession.session_id}_recording.webm`);
                        formData.append('session_id', examSession.session_id);
                        formData.append('duration', recordingDuration);
                        
                        await fetch(`${API_URL}/proctoring/upload-recording`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            },
                            body: formData
                        });
                        
                        console.log('Video uploaded successfully');
                    } catch (error) {
                        console.error('Error uploading video:', error);
                    }
                    
                    resolve();
                };
                
                mediaRecorder.stop();
            });
        }
        
        // Heartbeat to server
        setInterval(() => {
            fetch(`${API_URL}/proctoring/heartbeat`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    session_id: examSession.session_id
                })
            }).catch(err => console.error('Heartbeat failed:', err));
        }, 30000);
        
        // Prevent browser back button
        history.pushState(null, null, location.href);
        window.onpopstate = function() {
            history.go(1);
        };
    </script>
</body>
</html>
